# 55. Jump Game
## code(First intuition)
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        current_max_heap = nums[0]
        max_heap = 0
        if len(nums) != 1 and nums[0] == 0:
            return False
        if len(nums) == 1:
            return True
        for i in range(1, len(nums)):
            max_heap = max(max_heap, nums[i] + i)
            if i == current_max_heap:
                if max_heap <= current_max_heap:
                    return False
                else:
                    current_max_heap = max_heap

        return True
```
## code (correct)
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        current_max_heap = nums[0]
        max_heap = 0
        if len(nums) != 1 and nums[0] == 0:
            return False
        if len(nums) == 1:
            return True
        for i in range(1, len(nums)):
            max_heap = max(max_heap, nums[i] + i)
            if i == current_max_heap:
                if max_heap <= current_max_heap:
                    return False
                else:
                    current_max_heap = max_heap

        return True
```
## idea
The goal of this problem is to determine whether it's possible to reach the last index.
At first, I tried to apply the same idea I used in the previous jump problem (Jump Game II - LeetCode 45), but this problem is simpler since it only asks whether reaching the end is possible.
So the approach is to iterate through each element and update the furthest reachable index.
If at any point we can no longer move forward (i.e., the current index is beyond the reachable range), we return False. Otherwise, if we finish the loop, we return True.
> **note**: DP solutions I thought of always exceed time limit.
## percentage
![](/assetPic/jp1.png)
