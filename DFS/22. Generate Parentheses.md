# 22. Generate Parentheses
## code
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def dfs(openP, closeP, ans):
            if openP == closeP and openP + closeP == 2*n:
                res.append(ans)
                return
            if openP < n:
                dfs(openP + 1, closeP, ans + "(")
            if closeP < openP:
                dfs(openP, closeP + 1, ans + ")")

        dfs(0, 0, "")
        return res
```
## idea
This problem is about generating all valid combinations of `n` pairs of parentheses. The core rule is simple: every `closeP` must be preceded by a matching `openP`. Therefore, the DFS is divided into two main cases.

The first case is: if there are unmatched `openP`s available, we explore the branch that adds a `closeP`.
The second case is: as long as the number of `openP` is less than `n`, we explore the branch that adds an `openP`.

The recursion continues until both `openP` and `closeP` reach `n` and are equal, which means we have formed a valid parentheses combination.

The number of valid combinations corresponds to the n-th Catalan number, which is:

$$
C_n = \frac{1}{n+1} \binom{2n}{n}
$$

Thus, the time complexity is **O(4ⁿ / √n)**, which is exponential. However, since the algorithm only generates valid combinations, the performance is acceptable and efficient in practice.
## percentage
![](/assetPic/gp1.png)
