# 47. Permutations II
## code
```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def build(now: List[int], left: List[int]):
            nonlocal res
            if len(left) == 0:
                res.append(now[:])
                return
            for i in range(len(left)):
                if i > 0 and left[i] == left[i-1]: continue
                build(now + [left[i]], left[:i] + left[i+1:])
        build([], nums)
        return res
```
## idea
The goal of this problem is to generate all unique permutations of a list of numbers, meaning each permutation must not repeat. This is a classic backtracking problem, and although it was my first time implementing this technique, I had a solid grasp of the overall logic—such as choosing a number to add to `now`, passing the remaining elements to `left` for recursion, and backtracking by removing the last element. However, I'm still not familiar with some common pitfalls in backtracking:

1. I need to use `now[:]` to store a copy of the path, or later modifications will affect previous results.
2. After popping an element from `left`, restoring it with `append()` is not enough; the original order must be preserved.
3. To implement deduplication (pruning), sorting `nums` beforehand is essential, so we can skip duplicate numbers correctly.
   These details are easy to overlook but crucial for mastering backtracking, and I feel that I’ve learned a lot from correcting these mistakes.

The time complexity is O(n!) in the worst case, though reduced by deduplication.
The space complexity is O(n \* n!), due to storing all permutations of length `n`.
## percentage
![](/assetPic/p2.png)