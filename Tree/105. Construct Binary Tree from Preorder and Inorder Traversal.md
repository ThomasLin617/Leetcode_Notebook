# 105. Construct Binary Tree from Preorder and Inorder Traversal
## code
### first ($O(N^2)$)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        preorder = deque(preorder)

        def build(preorder, inorder):
            if inorder:
                idx = inorder.index(preorder.popleft())
                root = TreeNode(inorder[idx])

                root.left = build(preorder, inorder[:idx])
                root.right = build(preorder, inorder[idx+1:])

                return root

        return build(preorder, inorder)

            


```
### second ($O(N)$)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        mapping = {}

        for i in range(len(inorder)):
            mapping[inorder[i]] = i


        preorder = deque(preorder)

        def build(start, end):
            if start > end:
                return None
        
            root = TreeNode(preorder.popleft())
            mid = mapping[root.val]

            root.left = build(start, mid-1)
            root.right = build(mid+1, end)

            return root

        return build(0, len(inorder)-1)
```
## idea
The goal of this problem is to reconstruct a binary tree from two arrays: one representing the preorder traversal and the other representing the inorder traversal. Along the way, I encountered several concepts for the first time—from the new list-like data structure `deque` to the recursive logic of tree construction—which gave me many new insights.

First, I learned about the `deque` data structure. Since Python lists take O(n) time to remove an element from the front (`pop(0)`), they are inefficient for frequent front-removal operations. In contrast, `collections.deque` allows O(1) time `popleft()`, making it ideal for solutions that need to continuously extract the next element.

Next, I understood the practical significance of `preorder` and `inorder` traversals in tree reconstruction. Because `preorder` visits the root node first, each recursive call naturally processes the root of the current subtree. Meanwhile, the root in `inorder` appears in the middle, allowing us to determine the boundaries of the left and right subtrees. This makes it possible to recursively slice `inorder` and rebuild the entire tree step by step.

Lastly, I learned how to optimize the time complexity. The original approach uses slicing and `index()`, which results in O(n²) time due to repeated scanning and copying of array segments. However, by building a hash map (dictionary) for constant-time O(1) lookups and replacing slicing with index-based range control, we can avoid unnecessary data copying and reduce the overall time complexity from O(n²) to O(n).
## percentage
### first ($O(N^2)$)
![](/assetPic/cbtf.png)
### second ($O(N)$)
![](/assetPic/cbts.png)
