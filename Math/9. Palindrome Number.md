# 9. Palindrome Number
## code (First)
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        elif x == 0:
            return True
        x_s = str(x)
        if len(x_s) % 2 == 0:
            left = len(x_s) // 2 - 1
            right = left + 1
            while right < len(x_s):
                if x_s[left] != x_s[right]:
                    return False
                left -= 1
                right += 1
            return True
        axis = len(x_s) // 2
        dist = 0
        while axis + dist < len(x_s):
            if x_s[axis + dist] != x_s[axis - dist]:
                return False
            dist += 1
        return True
```
## code (Optimized based on the first solution)
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        x_s = str(x)
        left, right = 0, len(x_s) - 1
        while left < right:
            if x_s[left] != x_s[right]:
                return False
            left += 1
            right -= 1
        return True
```
## code (Verion str)
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        x_s = str(x)
        return x_s == x_s[::-1]
```
## idea
The goal of this problem is to determine whether a given integer is a palindrome. Since the problem is relatively simple, I was able to write a working and reasonably efficient solution on my own (First). My initial approach handled odd and even digit counts separately, checking digits outward from the center.

Later, I optimized it into a two-pointer solution that compares digits from both ends moving inward (Optimized based on the first solution). This version is more intuitive and significantly improves readability.

Finally, since we're using Python, there's a built-in slicing trick that allows us to reverse a string easily. This leads to the cleanest version: `x_s == x_s[::-1]` (Version str). Although this is the most readable, it's no longer a math-based solution but rather a string manipulation trick.

**Complexity:**

* First solution: Time O(n), Space O(1)
* Optimized solution: Time O(n), Space O(1)
* Version str: Time O(n), Space O(n) (due to string conversion and reversal)
## percentage(First)
![](/assetPic/pnf.png)
## percentage(Optimized based on the first solution)
![](/assetPic/pns.png)
## percentage(Verion str)
![](/assetPic/pnt.png)
