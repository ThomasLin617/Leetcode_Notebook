# 29. Divide Two Integers
## code
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        sign = -1 if (dividend < 0) ^ (divisor < 0) else 1
        print(sign)
        if divisor == dividend:
            return 1
        end, sor = abs(dividend), abs(divisor)
        res = 0
        while end >= sor:
            p = 0
            while end >= (sor << p):
                p += 1
            p -= 1
            end -= (sor << p)
            res += (1 << p)
        return max(min(sign*res, 2 ** 31 - 1), -2 ** 31)
```
## idea
The goal of this problem is to implement integer division **without using multiplication, division, or modulus operators**.

Initially, I considered using **repeated subtraction**, where the divisor is subtracted from the dividend until the remainder is smaller than the divisor. However, this approach has a time complexity of **O(N)** and becomes extremely inefficient when the dividend is large, leading to a time limit exceeded error.

Later, I learned a more efficient method using **bit shifting**. By left-shifting the divisor (i.e., multiplying it by powers of 2), we can rapidly approach the dividend. Since each step doubles the divisor, it skips many values in between, so once we overshoot, we must step back and try smaller powers of 2 again. This process repeats until no further subtraction is possible.

This method resembles a greedy strategy and constructs the quotient using powers of two. The overall time complexity is **O(logÂ²N)**, which significantly improves performance.

## percentage
![](/assetPic/dti.png)