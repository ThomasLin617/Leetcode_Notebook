# 7. Reverse Integer
## code
```python
class Solution:
    def reverse(self, x: int) -> int:
        res = 0
        neg = 0
        if x < 0:
            neg = 1
        elif x == 0:
            return 0 
        x = abs(x)
        while x != 0:
            res *= 10
            res += x %  10
            x = x // 10
        if neg == 1:
            res = res * -1
        
        if abs(res) >= 2 ** 31:
            return 0
        return res
```
## idea
The goal of this problem is to reverse an integer, while taking care of the sign and potential overflow. My initial idea was to handle it mathematically instead of converting it to a string: at each step, I took the last digit using `x % 10` and appended it to the result `res`, then divided `x` by 10 until it became 0. I used a flag `neg` to manage the sign, and at the end, I checked whether the result exceeded the 32-bit signed integer range. This problem helped me get familiar with digit-level operations and overflow checking, and it reinforced how to properly manage signs and boundary conditions in integer arithmetic.

* **Time Complexity**: O(log₁₀x), because we divide x by 10 in each step.
* **Space Complexity**: O(1), using only constant extra space.
## percentage
![](/assetPic/ri.png)
