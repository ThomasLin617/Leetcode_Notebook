# 43. Multiply Strings
## code
```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if int(num1) == 0 or int(num2) == 0:
            return "0"

        m = len(num1)
        n = len(num2)

        res = [0] * (m + n)

        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                result = mul + res[p2]
                res[p2] = result % 10
                res[p1] += result // 10

        res = "".join(map(str, res)).lstrip('0')
        return res
```
## idea
The goal of this problem is to **simulate the multiplication of two non-negative integers represented as strings, without using the `*` operator**.
At first, I tried to multiply each digit and shift the result by powers of 10, but that approach led to errors due to repeated multiplications.

Eventually, I found that using an array of size `m + n` to store intermediate results was the most straightforward method.
The hardest part of the problem is **determining the correct index in the result array where each digit multiplication should be placed**. Since it's not easy to derive a formula intuitively, I found it helpful to **write out vertical multiplication by hand** to figure out the correct placement.

### Conclusion:
* The maximum number of digits in `num1 × num2` is `len(num1) + len(num2)`
* The product of `num1[i] × num2[j]` should be added to `res[i + j + 1]` (the unit place)
* The carry should be added to `res[i + j]`
* (Assuming `i` and `j` are iterated from right to left)

### complexity: 
**Time complexity:** O(m × n), where m and n are the lengths of `num1` and `num2`
**Space complexity:** O(m + n), used for storing the result array
## percentage
![](/assetPic/ms.png)