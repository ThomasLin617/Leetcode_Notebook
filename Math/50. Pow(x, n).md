# 50. Pow(x, n)
## code
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1.0

        neg = n < 0
        n = abs(n)
        result = 1.0
        while n:
            if n % 2 == 1:
                result *= x
            x *= x
            n >>= 1
        
        return 1/result if neg else result
```
## idea
The goal of this problem is to implement exponentiation. At first I used a brute-force method—multiplying x by itself n times—but its time complexity is too high and it timed out. Later I learned to use **fast exponentiation** to avoid this issue. The idea is to decompose the exponent n into a sum of powers of two; whenever the current bit is 1, we multiply the corresponding value into the result and move on to the next bit. This changes the process from “incrementing the exponent by one each time” to “doubling the exponent each time,” reducing the time complexity from O(N) to O(log N).
## percentage
![](/assetPic/pownx.png)