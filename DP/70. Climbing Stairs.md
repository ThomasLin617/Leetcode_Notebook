# 70. Climbing Stairs
## code(recursive)
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        @lru_cache(maxsize=None)
        def climb(left):
            if left == 0:
                return 1
            elif left < 0:
                return 0

            return climb(left- 2) + climb(left-1)
        return climb(n)
```
## code(dp)
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0] * n
        if n == 1:
            return 1
        if n == 2:
            return 2
        dp[0] = 1
        dp[1] = 2
        for i in range(2,n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]
```
## code (dp-space optimized)
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        third = 0
        if n == 1:
            return 1
        if n == 2:
            return 2
        first = 1
        second = 2
        for i in range(2,n):
            third = first + second
            first, second = second, third
        return third
```
## idea
The goal of this problem is to calculate the total number of ways to climb `n` stairs, where you can take either 1 or 2 steps at a time.

At first, I tried solving it using plain recursion, but it quickly ran into time limit issues for larger inputs.
Later, I learned about Python's built-in `@lru_cache` decorator, which caches intermediate results and effectively prevents redundant computation — this successfully resolved the timeout problem.
I then switched to a dynamic programming (DP) approach, and found that it achieves the same performance without requiring a decorator.
Finally, I further optimized the solution by compressing the DP array into just three variables, reducing the space complexity.


### Complexity(table made by GPT):

| Method                  | Time Complexity | Space Complexity | Notes          |
| ----------------------- | --------------- | ---------------- | -------------- |
| Recursion (no memo)     | O(2ⁿ)           | O(n)             | TLE            |
| Recursion + `lru_cache` | O(n)            | O(n)             | Uses caching   |
| DP with array           | O(n)            | O(n)             |  |
| DP with space reduction | O(n)            | O(1)             | Optimal        |



## percentage
### recursive
![](/assetPic/cs1.png)
### dp
![](/assetPic/cs2.png)
### dp-space optimized
![](/assetPic/cs3.png)