# 62. Unique Paths
## code
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * n for _ in range(m)]
        for i in range(n):
            dp[0][i] = 1
        for i in range(m):
            dp[i][0] = 1
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[m-1][n-1]
```
## idea
At first, I only thought of solving the problem using basic math — by applying the permutation and combination formula directly. This allowed me to quickly compute the answer.
However, the main purpose of this problem is to practice dynamic programming (DP), which is also quite intuitive.

We assign a dp value to each grid cell.
We initialize the entire first row and first column as 1, since there's only one way to reach those positions.
For all other cells, the number of unique paths is the sum of the cell directly above and the cell to the left.
By iterating through the grid and filling in the dp table, we can get the correct answer at the bottom-right corner.

### Complexity:

Time: O(m × n)  
We visit every cell in the m × n grid once  
Space: O(m × n)                  

>**Note:** Space complexity can be reduced by using a 1D array and updating it in place with  
>`dp[j] = dp[j] + dp[j - 1]`
## percentage
![](/assetPic/up.png)
