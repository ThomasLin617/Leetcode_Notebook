# 53. Maximum Subarray
## code(dp)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        dp = [-1] * len(nums)
        dp[0] = nums[0]
        res = dp[0]
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], dp[i-1]+nums[i])
            res = max(res, dp[i])
        return res
```
## code(Kadane)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = nums[0]
        current = 0

        for i in nums:
            if current < 0 :
                current = 0
            current += i
            res = max(res, current)

        return res
```
## idea
The goal of this problem is to find the **maximum sum of a contiguous subarray**.
I first learned the **DP (Dynamic Programming)** approach, which uses a `dp` array. For each element, I add it to the maximum sum up to the previous position. If the current element itself is larger, I discard the previous sum; otherwise, I continue accumulating.

Later, I learned about **Kadane's Algorithm**, which is specifically designed for finding the maximum sum of a contiguous subarray. The idea is that if the current total sum is negative, it should be discarded, and we start fresh from the current element. This allows us to achieve the same result **without using extra space**.

* DP approach: Time complexity O(n), Space complexity O(n)
* Kadane's Algorithm: Time complexity O(n), Space complexity O(1)

## percentage(dp)
![](/assetPic/msd.png)
## percentage(Kadane)
![](/assetPic/msk.png)
