# 32. Longest Valid Parentheses
## code
### DP
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0] * n
        ans = 0
        for i in range(1, n):
            if s[i] == ")":
                if s[i-1] == "(":
                    dp[i] = dp[i-2] + 2
                if s[i-1] == ")" and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == "(" :
                    dp[i] = dp[i-1] + 2
                    if i - dp[i-1] - 2 >= 0:
                        dp[i] += dp[i - dp[i-1] - 2]
            ans = max(ans, dp[i])

        return ans

```
### stack
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        res = 0
        for i in range(len(s)):
            if s[i] == "(":
                stack.append(i)
            elif s[i] == ")":
                stack.pop()
                if len(stack) == 0:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])

        return res
```
## idea
The goal is to find the length of the longest valid parentheses substring from a string `s` that contains only `'('` and `')'`, where "valid" means the parentheses are correctly matched and ordered. I learned two approaches to solve this problem.

The first approach is using dynamic programming (DP). The core idea is to define `dp[i]` as the length of the longest valid parentheses substring ending at position `i`. There are two cases: if `s[i]` is `')'` and `s[i-1]` is `'('`, it means a direct match, so `dp[i]` equals `dp[i-2] + 2`; if `s[i]` is `')'` and `s[i-1]` is also `')'`, we need to jump back to find a matching `'('`. If `s[i - dp[i-1] - 1]` is `'('`, then we can match and update `dp[i]` accordingly.

The second approach is using a stack to record unmatched `'('` positions or invalid `')'` positions. The stack is initialized with `-1` as a virtual boundary. For each `'('`, we push its index onto the stack; for each `')'`, we pop and attempt a match. If successful, we compute the valid length using `i - stack[-1]`, which represents the current length of a valid substring.

Both methods run in O(n) time complexity, but in practice, the stack-based approach performs faster and is more intuitive, as it doesn't require extra memory to store a dp array. Each approach has its own caveats: the DP method is more complex and requires clearly defined transition conditions, while the stack approach requires understanding why `-1` is used as the initial value and recognizing that an empty stack indicates an invalid state.

## percentage
### DP
![](/assetPic/lvpdp.png)
### stack
![](/assetPic/lpvs.png)