# 63. Unique Paths II
## code
```python
lass Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        rows = len(obstacleGrid)
        cols = len(obstacleGrid[0])
        dp = [[0] * cols for _ in range(rows)]
        for i in range(cols):
            if obstacleGrid[0][i] == 1:
                break
            dp[0][i] = 1

        for i in range(rows):
            if obstacleGrid[i][0] == 1:
                break
            dp[i][0] = 1

        for i in range(1, rows):
            for j in range(1, cols):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                else:
                    dp[i][j] = dp[i][j-1] + dp[i-1][j]

        return dp[-1][-1]

```
## idea
The goal of this problem is to find the number of unique paths from the top-left to the bottom-right corner, similar to **Unique Paths I**, but with the addition of obstacles.

The solution still uses dynamic programming (DP). We iterate through the grid and for each cell:

* If the cell contains an obstacle (`1`), it is unreachable, so we set its DP value to `0`.
* If it is not an obstacle, the number of ways to reach it is the sum of the top and left cells.

Since obstacle cells are already set to `0`, we can directly compute
`dp[i][j] = dp[i-1][j] + dp[i][j-1]` without any extra condition checks.

**Complexity:**

* **Time:** O(m × n)
* **Space:** O(m × n), which can be optimized to **O(n)** using a 1D DP array.
## percentage
![](/assetPic/up2.png)
