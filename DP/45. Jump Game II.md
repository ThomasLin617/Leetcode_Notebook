# 45. Jump Game II
## code (greedy)
```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        jumps = 0
        further = 0
        current = 0
        for i in range(len(nums)-1):
            further = max(further, nums[i]+i)
            if i == current:
                jumps += 1
                current = further

        return jumps
```
## code (dp)
```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        dp = [float('inf')] * len(nums)
        dp[0] = 0
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[j] + j >= i:
                    dp[i] = min(dp[i], dp[j]+1)

        return dp[-1]
```
## idea
The goal of this problem is to calculate the minimum number of jumps needed to reach `nums[n - 1]` from `nums[0]`.

I first learned the **greedy approach**: at each jump, record the furthest position reachable in the current jump, and within that range, find the furthest position reachable for the next jump. Once the current index reaches the end of the current range, it means a new jump is needed, and we update the jump count and the range.

Since this method only requires a single pass through `nums` and no additional memory, the complexity is:

- **Time Complexity**: `O(n)`
- **Space Complexity**: `O(1)`

However, since my current goal is to practice **dynamic programming (DP)**, I also implemented a DP solution.

In the DP approach, for each position `i`, we check all previous positions `j` that can reach `i`. If reachable, we try updating `dp[i]` with `dp[j] + 1`.

This method checks all previous positions for each `i` and requires an additional array to store results. Therefore, the complexity is:

- **Time Complexity**: `O(nÂ²)`
- **Space Complexity**: `O(n)`

Although DP is more intuitive and suitable for beginners to practice, in terms of efficiency, the greedy approach remains the optimal solution for this problem.

## percentage(greedy)
![](/assetPic/jgg.png)

## percentage(dp)
![](/assetPic/jgd.png)
