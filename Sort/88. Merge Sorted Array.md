# 88. Merge Sorted Array
## code
```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i = m - 1
        j = n - 1
        k = len(nums1) - 1
        while i >= 0 and j >= 0:
            if nums1[i] >= nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
                k -= 1
            if nums1[i] < nums2[j]:
                nums1[k] = nums2[j]
                j -= 1
                k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```
## idea
The goal of this problem is to merge two sorted arrays, `nums1` and `nums2`, into one sorted array by modifying `nums1` in-place. At first, I tried inserting from the front, but quickly realized that this would overwrite existing elements in `nums1`, causing errors. The correct strategy is to **start from the back and fill in the largest values first**. This involves using three pointers: `i` for the end of valid `nums1`, `j` for the end of `nums2`, and `k` for the overall end of `nums1`. In each step, we compare `nums1[i]` and `nums2[j]` and place the larger one at `nums1[k]`, then move the pointers accordingly. This is the first time I've solved a merge problem by processing from the end backward, and I learned that in-place operations require extra care with index movement. Also, it's important to remember to copy any remaining elements from `nums2` at the end, or some values may be lost. Although the logic is not difficult, this problem contains many subtle points that can easily go wrong.

Time complexity is O(m + n), since each element is processed at most once.
Space complexity is O(1), as the merging is done entirely in-place.
## percentage
![](/assetPic/msa.png)